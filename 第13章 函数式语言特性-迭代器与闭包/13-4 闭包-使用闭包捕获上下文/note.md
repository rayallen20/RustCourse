# PART1. 闭包可以捕获他们所在的环境

- 闭包可以访问定义它的作用域内的变量,而普通函数不能访问

```rust
fn main() {
    let x = 4;

    // 此处闭包的函数体中的x不是函数的参数,而是和闭包定义在同一个作用域内的变量
    let equal_to_x = |z| z == x;

    let y = 4;

    assert!(equal_to_x(y));
}
```

- 捕获环境这一功能会产生内存开销,因为闭包会捕获环境中的变量,这些变量会被存储在闭包的结构体中,而不是在栈上

# PART2. 闭包从所在环境捕获值的方式

与函数获得参数的3种方式一样:

1. 取得所有权: 对应FnOnce Trait.该Trait表示闭包可以从所在环境中取得变量的所有权,并且将变量移动到闭包中.而FnOnce这个名称也体现了这个意思,因为闭包不可能多次获取并消耗同一个变量的所有权,所以闭包只能被调用一次
2. 可变借用: 对应FnMut Trait.该Trait表示闭包可以从所在环境中获取可变借用,而不会获取所有权.这意味着闭包可以改变所捕获的变量的值,但是不会获取所有权
3. 不可变借用: 对应Fn Trait.该Trait表示闭包从所在环境中获取不可变借用,这意味着闭包不能改变所捕获的变量的值

当你在创建闭包时,Rust会根据闭包如何使用环境值来推断闭包所需要的Trait

- 所有的闭包都实现了FnOnce
  - 这个很好理解,因为所有的闭包都可以被调用至少一次
- 不需要对捕获的变量进行所有权移动的闭包实现了FnMut
- 不需要对捕获的变量进行可变访问的闭包实现了Fn

# PART3. move关键字

在参数列表前使用`move`关键字,可以强制闭包获取其使用的环境值的所有权

使用场景: 当将闭包传递给新线程时,需要使用`move`关键字,因为新线程的运行环境与创建它的线程不同,所以需要将闭包的环境值移动到新线程中

```rust
fn main() {
    let x = vec![1, 2, 3];

    let equal_to_x = move |z| {z == x};

    // 此处已经不能再访问x了 因为x的所有权已经被闭包消耗掉了
    println!("can't use x here: {:?}", x);  // error: value borrowed here after move

    let y = vec![1, 2, 3];

    assert!(equal_to_x(y));
}
```

注: 这里和我想的不太一样.我以为是当闭包被调用时,才会获取环境值的所有权,而不是在闭包创建时就获取所有权.而实际上`move`关键字是在闭包创建时就获取环境值的所有权

# PART4. 最佳实践

当指定Fn Trait Bound时,首先使用Fn Trait,然后基于闭包体里的情况:

- 如果需要可变访问,再使用FnMut Trait
- 如果需要获取所有权,再使用FnOnce Trait
- 这两点编译器会告诉你