// let v: Vec<u32> = vec![1, 2, 3];

// #[macro_export]: 表示该宏需要在其所属的包被引入作用域后,方可使用
// 没有该标注的宏,则不能被引入作用域
#[macro_export]
// 本代码为一个简化版的vec!宏的实现
// macro_rules!关键字: 用于定义宏
macro_rules! vec {
    // 声明宏内部的代码有点像match表达式的各个分支
    // 本例中,只有1个分支 即: ( $( $x:expr ), * ) 可以把它看成是一个模式
    // 由于我们自己手搓的vec宏只有1种有效的模式,因此其他模式会导致编译错误 可以认为如果我们调用这个自己手搓的vec宏时
    // 传入的参数不符合这个模式,那么编译器会报错
    // 某些比较复杂的宏,则会有多个模式
    // 但是声明宏中的代码和match表达式还是有本质区别的 声明宏匹配的是Rust的代码结构 match表达式匹配的是值

    // $x:expr: expr是一个模式,表示任意表达式;$x是一个变量名,表示匹配到的任意表达式
    // 这句话的意思就是匹配任何表达式,并将其绑定到变量$x上
    // ,: 表示被捕获的表达式后边可能(注意是可能而不是必须)会出现一个,
    // $( $x:expr )中的$(): 表示捕获的表达式将被包装成一个数组
    // *: 表示捕获的表达式可以出现0次或多次 这里捕获表达式指的就是 $( $x:expr )
    // 也就是说,这里捕获到的表达式 就是 let v: Vec<u32> = vec![1, 2, 3]; 中的 1 2 3
    ( $( $x:expr ), * ) => {
        {
            let mut temp_vec = Vec::new();
            // 这里的 $()*表示针对 $( $x:expr ), * 捕获到的每一个表达式$x
            // 都执行一次其中的代码块
            // $()内部是要重复执行的代码
            // *表示这段代码可以被重复执行0次或多次 具体数量取决于有多少个$x被捕获到
            $(
                temp_vec.push($x);
            )*
            // 这里的temp_vec是一个表达式,表示这个宏最终会返回temp_vec
            temp_vec
        }
    };
}

// 这个宏最终生成的代码效果大致如下:
// let mut temp_vec = Vec::new();
// temp_vec.push(1);
// temp_vec.push(2);
// temp_vec.push(3);
// temp_vec